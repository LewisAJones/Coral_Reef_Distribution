panel.grid.major.y = element_line(colour = NA),
panel.grid.major.x = element_line(colour = NA),
legend.position = c(0.1, 0.925),
legend.title = element_blank(),
legend.background = element_blank(),
legend.key = element_rect(colour = NA, fill = NA),
legend.key.size = unit(0.75, "lines"),
legend.key.width = unit(0.75, "cm"),
legend.text = element_text(size = 10),
panel.border = element_rect(colour = "black", fill = NA),
plot.subtitle = element_text(size = 10, angle = 0, hjust = 0.5),
axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5),
axis.text.y = element_text(size = 14, angle = 0, hjust = 0),
axis.title.y = element_text(size = 14, face = "bold", vjust = 2),
axis.text.y.right = element_text(size = 14, angle = 0, hjust = 0),
axis.title.y.right = element_text(size = 14, face = "bold", vjust = 2),
axis.title.x = element_text(size = 14, face = "bold", vjust = -1),
aspect.ratio = 1)
p1 <- p1 + geom_text(x = 340, y = 45, label = lm_eqn(df = data, x = data$LPT_global, y = data$n), colour = "black", size = 3, parse = TRUE)
#p1
#MAXSSS
p2 <- ggplot(data = data, aes()) +
geom_point(aes(x = MaxSSS_global, y = n), shape = 21, fill = data$color, colour = "black", size = 2, alpha = 1) +
geom_smooth(aes(x = MaxSSS_global, y = n), method='lm', colour = "black", formula= y~x) +
labs(x = expression(bold(paste("Suitable habitat area (",10^6~km^2,")",sep=""))), y = "Number of reef sites", subtitle = "Maximising the sum of sensitivity and specificity") +
theme(panel.background = element_rect(colour = "white", fill = "white"),
plot.margin = margin(0.5,0.5,0.5,0.5, "cm"),
panel.grid.minor.y = element_line(colour = NA),
panel.grid.minor.x = element_line(colour = NA),
panel.grid.major.y = element_line(colour = NA),
panel.grid.major.x = element_line(colour = NA),
legend.position = c(0.1, 0.925),
legend.title = element_blank(),
legend.background = element_blank(),
legend.key = element_rect(colour = NA, fill = NA),
legend.key.size = unit(0.75, "lines"),
legend.key.width = unit(0.75, "cm"),
legend.text = element_text(size = 10),
panel.border = element_rect(colour = "black", fill = NA),
plot.subtitle = element_text(size = 10, angle = 0, hjust = 0.5),
axis.text.x = element_text(size = 14, angle = 0, hjust = 0.5),
axis.text.y = element_text(size = 14, angle = 0, hjust = 0),
axis.title.y = element_text(size = 14, face = "bold", vjust = 2),
axis.text.y.right = element_text(size = 14, angle = 0, hjust = 0),
axis.title.y.right = element_text(size = 14, face = "bold", vjust = 2),
axis.title.x = element_text(size = 14, face = "bold", vjust = -1),
aspect.ratio = 1)
p2 <- p2 + geom_text(x = 250, y = 45, label = lm_eqn(df = data, x = data$MaxSSS_global, y = data$n), colour = "black", size = 3, parse = TRUE)
#p2
p <- ggarrange(p1, p2, labels = c("A", "B"), ncol = 2)
#p
ggsave("./figures/linear_models.jpg", plot = p, width = 70, height = 35, units = "mm", dpi = 600, scale = 3)
#model performance
library(raster)
source("./R/options.R")
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")[,c("interval_name","P.Long", "P.Lat")]
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[1:52,] #subset to stages of interest
#---------------------------------
#LPT
files <- list.files("./results/Predictions/Binary/LPT/", pattern = ".asc")
files <- files[!files == "Modern.asc"]
stk <- stack(paste("./results/Predictions/Binary/LPT/", files, sep = ""))
master <- data.frame()
1
#load rasters
r <- stk[[i]]
i <- 1
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
#remove points falling inside continents
ext <- extract(x = r, y = xy)
vec <- which(!is.na(ext))
xy <- xy[vec,]
#skip if no points for testing
if(nrow(xy) == 0){success <- NA; failure <- NA; n <- 0; perf <- NA; buffer_perf <- NA; upper <- NA; mean <- NA; lower <- NA; pval <- NA
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, upper, mean, lower, pval)
master <- rbind.data.frame(master, df)
next}
#calculate predictive performance
ext <- extract(x = r, y = xy) #extract data
success <- sum(ext == 1, na.rm = TRUE) #success
failure <- sum(ext == 0, na.rm = TRUE) #failed
n <- nrow(xy) #number of points
perf <- (success/n)*100 #calculate percentage
#calculate buffered predictive performance
buffer_ext <- sapply(1:nrow(xy), function(x){
pts <- xy[x,]
cells <- cellFromXY(object = r, xy = pts)
cells <- append(cells, adjacent(x = r, cells = cells, directions = 8, pairs = FALSE))
cells <- r[cells]
}, simplify = TRUE)
buffer_ext <- colSums(buffer_ext, na.rm = TRUE)
buffer_ext[buffer_ext > 1] <- 1
buffer_perf <- (sum(buffer_ext)/length(buffer_ext))*100
#calculate random predictive performance
r <- getValues(r)
#r <- na.omit(r)
r[is.na(r)] <- 0
xy_rand <- replicate(n = 1000, sample(x = r, size = n, replace = TRUE), simplify = FALSE)
rand_perf <- data.frame(dplyr::bind_cols(xy_rand))
vals <- (colSums(rand_perf)/length(ext))*100
rand_perf <- t(data.frame(Rmisc::CI(vals, ci = 0.95)))
#wilcox test
pval <- wilcox.test(x = perf, y = vals, alternative = "greater")$p.value
pval
wilcox.test(x = perf, y = vals, alternative = "greater")
?wilcox.test
W <- wilcox.test(x = perf, y = vals, alternative = "greater")$W
W
W <- wilcox.test(x = perf, y = vals, alternative = "greater")
W$statistic
W <- wilcox.test(x = perf, y = vals, alternative = "greater")$statistic
W
W <- as.numeric(wilcox.test(x = perf, y = vals, alternative = "greater")$statistic)
W
pval
perf
vals
wilcox.test(x = perf, y = vals, alternative = "greater")
wilcox.test(mu = perf, y = vals, alternative = "greater")
wilcox.test(mu = perf, x = vals, alternative = "greater")
wilcox.test(mu = perf, x = vals, alternative = "less")
wilcox.test(mu = perf, x = vals, alternative = "less")$p.value
as.numeric(wilcox.test(mu = perf, x = vals, alternative = "less")$statistic)
wilcox.test(mu = perf, x = vals, alternative = "less")
wilcox.test(mu = perf, x = vals, alternative = "less")
wilcox.test(mu = perf, x = vals)
perf
vals
max(vals)
as.numeric(wilcox.test(mu = perf, x = vals, alternative = "less")$statistic)
#model performance
library(raster)
source("./R/options.R")
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")[,c("interval_name","P.Long", "P.Lat")]
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[1:52,] #subset to stages of interest
#---------------------------------
#LPT
files <- list.files("./results/Predictions/Binary/LPT/", pattern = ".asc")
files <- files[!files == "Modern.asc"]
stk <- stack(paste("./results/Predictions/Binary/LPT/", files, sep = ""))
master <- data.frame()
for(i in 1:nlayers(stk)){
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
#remove points falling inside continents
ext <- extract(x = r, y = xy)
vec <- which(!is.na(ext))
xy <- xy[vec,]
#skip if no points for testing
if(nrow(xy) == 0){success <- NA; failure <- NA; n <- 0; perf <- NA; buffer_perf <- NA; upper <- NA; mean <- NA; lower <- NA; pval <- NA
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, upper, mean, lower, pval)
master <- rbind.data.frame(master, df)
next}
#calculate predictive performance
ext <- extract(x = r, y = xy) #extract data
success <- sum(ext == 1, na.rm = TRUE) #success
failure <- sum(ext == 0, na.rm = TRUE) #failed
n <- nrow(xy) #number of points
perf <- (success/n)*100 #calculate percentage
#calculate buffered predictive performance
buffer_ext <- sapply(1:nrow(xy), function(x){
pts <- xy[x,]
cells <- cellFromXY(object = r, xy = pts)
cells <- append(cells, adjacent(x = r, cells = cells, directions = 8, pairs = FALSE))
cells <- r[cells]
}, simplify = TRUE)
buffer_ext <- colSums(buffer_ext, na.rm = TRUE)
buffer_ext[buffer_ext > 1] <- 1
buffer_perf <- (sum(buffer_ext)/length(buffer_ext))*100
#calculate random predictive performance
r <- getValues(r)
#r <- na.omit(r)
r[is.na(r)] <- 0
xy_rand <- replicate(n = 1000, sample(x = r, size = n, replace = TRUE), simplify = FALSE)
rand_perf <- data.frame(dplyr::bind_cols(xy_rand))
vals <- (colSums(rand_perf)/length(ext))*100
rand_perf <- t(data.frame(Rmisc::CI(vals, ci = 0.95)))
#wilcox test
pval <- wilcox.test(mu = perf, x = vals, alternative = "less")$p.value
V <- as.numeric(wilcox.test(mu = perf, x = vals, alternative = "less")$statistic)
#bind data
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, rand_perf, V, pval)
rownames(df) <- NULL
master <- rbind.data.frame(master, df)
}
master
#model performance
library(raster)
source("./R/options.R")
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")[,c("interval_name","P.Long", "P.Lat")]
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[1:52,] #subset to stages of interest
#---------------------------------
#LPT
files <- list.files("./results/Predictions/Binary/LPT/", pattern = ".asc")
files <- files[!files == "Modern.asc"]
stk <- stack(paste("./results/Predictions/Binary/LPT/", files, sep = ""))
master <- data.frame()
for(i in 1:nlayers(stk)){
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
#remove points falling inside continents
ext <- extract(x = r, y = xy)
vec <- which(!is.na(ext))
xy <- xy[vec,]
#skip if no points for testing
if(nrow(xy) == 0){success <- NA; failure <- NA; n <- 0; perf <- NA; buffer_perf <- NA; upper <- NA; mean <- NA; lower <- NA; pval <- NA
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, upper, mean, lower, pval)
master <- rbind.data.frame(master, df)
next}
#calculate predictive performance
ext <- extract(x = r, y = xy) #extract data
success <- sum(ext == 1, na.rm = TRUE) #success
failure <- sum(ext == 0, na.rm = TRUE) #failed
n <- nrow(xy) #number of points
perf <- (success/n)*100 #calculate percentage
#calculate buffered predictive performance
buffer_ext <- sapply(1:nrow(xy), function(x){
pts <- xy[x,]
cells <- cellFromXY(object = r, xy = pts)
cells <- append(cells, adjacent(x = r, cells = cells, directions = 8, pairs = FALSE))
cells <- r[cells]
}, simplify = TRUE)
buffer_ext <- colSums(buffer_ext, na.rm = TRUE)
buffer_ext[buffer_ext > 1] <- 1
buffer_perf <- (sum(buffer_ext)/length(buffer_ext))*100
#calculate random predictive performance
r <- getValues(r)
#r <- na.omit(r)
r[is.na(r)] <- 0
xy_rand <- replicate(n = 1000, sample(x = r, size = n, replace = TRUE), simplify = FALSE)
rand_perf <- data.frame(dplyr::bind_cols(xy_rand))
vals <- (colSums(rand_perf)/length(ext))*100
rand_perf <- t(data.frame(Rmisc::CI(vals, ci = 0.95)))
#wilcox test
pval <- wilcox.test(mu = perf, x = vals, alternative = "less")$p.value
V <- as.numeric(wilcox.test(mu = perf, x = vals, alternative = "less")$statistic)
#bind data
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, rand_perf, V, pval)
rownames(df) <- NULL
master <- rbind.data.frame(master, df)
}
dir.create("./results/Performance/")
master <- left_join(x = master, y = stages, by = c("name" = "interval_name"))
master <- master[order(master$mid_ma),]
write.csv(master, "./results/Performance/LPT_results.csv", row.names = FALSE)
#maxSSS
files <- list.files("./results/Predictions/Binary/MaxSSS/", pattern = ".asc")
files <- files[!files == "Modern.asc"]
stk <- stack(paste("./results/Predictions/Binary/MaxSSS/", files, sep = ""))
master <- data.frame()
for(i in 1:nlayers(stk)){
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
#remove points falling inside continents
ext <- extract(x = r, y = xy)
vec <- which(!is.na(ext))
xy <- xy[vec,]
#skip if no points for testing
if(nrow(xy) == 0){success <- NA; failure <- NA; n <- 0; perf <- NA; buffer_perf <- NA; upper <- NA; mean <- NA; lower <- NA; pval <- NA
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, upper, mean, lower, pval)
master <- rbind.data.frame(master, df)
next}
#calculate predictive performance
ext <- extract(x = r, y = xy) #extract data
success <- sum(ext == 1, na.rm = TRUE) #success
failure <- sum(ext == 0, na.rm = TRUE) #failed
n <- nrow(xy) #number of points
perf <- (success/n)*100 #calculate percentage
#calculate buffered predictive performance
buffer_ext <- sapply(1:nrow(xy), function(x){
pts <- xy[x,]
cells <- cellFromXY(object = r, xy = pts)
cells <- append(cells, adjacent(x = r, cells = cells, directions = 8, pairs = FALSE))
cells <- r[cells]
}, simplify = TRUE)
buffer_ext <- colSums(buffer_ext, na.rm = TRUE)
buffer_ext[buffer_ext > 1] <- 1
buffer_perf <- (sum(buffer_ext)/length(buffer_ext))*100
#calculate random predictive performance
r <- getValues(r)
#r <- na.omit(r)
r[is.na(r)] <- 0
xy_rand <- replicate(n = 1000, sample(x = r, size = n, replace = TRUE), simplify = FALSE)
rand_perf <- data.frame(dplyr::bind_cols(xy_rand))
vals <- (colSums(rand_perf)/length(ext))*100
rand_perf <- t(data.frame(Rmisc::CI(vals, ci = 0.95)))
#wilcox test
pval <- wilcox.test(mu = perf, x = vals, alternative = "less")$p.value
V <- as.numeric(wilcox.test(mu = perf, x = vals, alternative = "less")$statistic)
#bind data
df <- cbind.data.frame(name, success, failure, n, perf, buffer_perf, rand_perf, V, pval)
rownames(df) <- NULL
master <- rbind.data.frame(master, df)
}
master <- left_join(x = master, y = stages, by = c("name" = "interval_name"))
master <- master[order(master$mid_ma),]
write.csv(master, "./results/Performance/MaxSSS_results.csv", row.names = FALSE)
beepr::beep(2)
# Copyright (c) Lewis A. Jones, 2021
# Email: LewisA.Jones@outlook.com
#
# Script name:
# model_performance_cont.R
#
# Script description:
# Calculate model performance
#
#-------------------------------------------------
library(raster)
library(dplyr)
source("./R/options.R")
#---------------------------------
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[6:50,] #subset to stages of interest
stages <- paste(unique(stages$interval_name), ".asc", sep = "")
stk <- stack(paste("./results/Predictions/Median/", stages, sep = ""))
dir.create("./results/Performance/")
dir.create("./results/Performance/plots/")
vec <- vector()
i <- 1
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
observed <- raster::extract(x = r, y = xy)
observed_mean <- mean(observed)
observed_mean
vals <- raster::sampleRandom(x = r, size = 1000, xy = FALSE, na.rm = TRUE)
random_mean <- mean(vals)
observed
vals
observed <- raster::extract(x = r, y = xy)
observed
observed_mean <- mean(observed)
observed_mean
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
observed <- raster::extract(x = r, y = xy)
observed_median <- median(observed)
vals <- raster::sampleRandom(x = r, size = 1000, xy = FALSE, na.rm = TRUE)
random_median <- median(vals)
p <- round(wilcox.test(x = observed, y = vals, alternative = "greater")$p.value, 3)
hist(vals, xlim = c(0, 1), ylim = c(0, 1000), col= "grey50", main = name, xlab = "Habitat suitability", ylab = "Frequency")
box()
abline(v = observed_median, col = "red", lty = 2, lwd = 2)
points(x = observed_median, y = 0, pch = 23, col = "black", bg = "red", cex = 1.3)
abline(v = random_median, col = "blue", lty = 2, lwd = 2)
points(x = random_median, y = 0, pch = 23, col = "black", bg = "blue", cex = 1.3)
#-------------------------------------------------
# Project: Coral_Reef_Distribution
#
# Date: 2021-10-29
# Author: Lewis A. Jones
# Copyright (c) Lewis A. Jones, 2021
# Email: LewisA.Jones@outlook.com
#
# Script name:
# model_performance_cont.R
#
# Script description:
# Calculate model performance
#
#-------------------------------------------------
library(raster)
library(dplyr)
source("./R/options.R")
#---------------------------------
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[6:50,] #subset to stages of interest
stages <- paste(unique(stages$interval_name), ".asc", sep = "")
stk <- stack(paste("./results/Predictions/Median/", stages, sep = ""))
dir.create("./results/Performance/")
dir.create("./results/Performance/plots/")
vec <- vector()
for(i in 1:nlayers(stk)){
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
observed <- raster::extract(x = r, y = xy)
#observed[is.na(observed)] <- 0
observed_median <- median(observed)
vals <- raster::sampleRandom(x = r, size = 1000, xy = FALSE, na.rm = TRUE)
random_median <- median(vals)
p <- round(wilcox.test(x = observed, y = vals, alternative = "greater")$p.value, 3)
if(p == 0){p <- 0.001}
jpeg(paste("./results/Performance/plots/", i, "_", name, ".jpg", sep = ""), width = 3000, height = 3000, res = 600)
hist(vals, xlim = c(0, 1), ylim = c(0, 1000), col= "grey50", main = name, xlab = "Habitat suitability", ylab = "Frequency")
box()
abline(v = observed_median, col = "red", lty = 2, lwd = 2)
points(x = observed_median, y = 0, pch = 23, col = "black", bg = "red", cex = 1.3)
abline(v = random_median, col = "blue", lty = 2, lwd = 2)
points(x = random_median, y = 0, pch = 23, col = "black", bg = "blue", cex = 1.3)
#text(x = 0.85, y = 950, paste('P-val', " = ", paste(p)))
#text(x = 0.85, y = 900, paste('n', " = ", nrow(xy)))
legend("topright",
legend = c(paste('P', " = ", paste(p)), paste('n', " = ", nrow(xy))),
bty = "n")
dev.off()
vec <- append(vec, p)
names(vec)[i] <- name
}
results <- file("./results/Performance/performance.txt")
writeLines(paste(names(vec), vec), results)
close(results)
beepr::beep(2)
W <- wilcox.test(x = observed, y = vals, alternative = "greater")$statistic
W
hist(vals, xlim = c(0, 1), ylim = c(0, 1000), col= "grey50", main = name, xlab = "Habitat suitability", ylab = "Frequency")
box()
abline(v = observed_median, col = "red", lty = 2, lwd = 2)
points(x = observed_median, y = 0, pch = 23, col = "black", bg = "red", cex = 1.3)
abline(v = random_median, col = "blue", lty = 2, lwd = 2)
points(x = random_median, y = 0, pch = 23, col = "black", bg = "blue", cex = 1.3)
#text(x = 0.85, y = 950, paste('P-val', " = ", paste(p)))
#text(x = 0.85, y = 900, paste('n', " = ", nrow(xy)))
legend("topright",
legend = c(paste('W', " = ", paste(W)), paste('P', " = ", paste(p)), paste('n', " = ", nrow(xy))),
bty = "n")
dev.off()
#-------------------------------------------------
# Project: Coral_Reef_Distribution
#
# Date: 2021-10-29
# Author: Lewis A. Jones
# Copyright (c) Lewis A. Jones, 2021
# Email: LewisA.Jones@outlook.com
#
# Script name:
# model_performance_cont.R
#
# Script description:
# Calculate model performance
#
#-------------------------------------------------
library(raster)
library(dplyr)
source("./R/options.R")
#---------------------------------
collections <- read.csv("./data/occurrences/PARED_subsampled.csv")
stages <- read.csv("./data/stage_bins.csv")
stages <- stages[6:50,] #subset to stages of interest
stages <- paste(unique(stages$interval_name), ".asc", sep = "")
stk <- stack(paste("./results/Predictions/Median/", stages, sep = ""))
dir.create("./results/Performance/")
dir.create("./results/Performance/plots/")
vec <- vector()
for(i in 1:nlayers(stk)){
#load rasters
r <- stk[[i]]
#get raster name for later use
name <- names(r)
#subset collection data
xy <- subset(collections, interval_name == name)[,c("P.Long", "P.Lat")]
observed <- raster::extract(x = r, y = xy)
#observed[is.na(observed)] <- 0
observed_median <- median(observed)
vals <- raster::sampleRandom(x = r, size = 1000, xy = FALSE, na.rm = TRUE)
random_median <- median(vals)
p <- round(wilcox.test(x = observed, y = vals, alternative = "greater")$p.value, 3)
W <- wilcox.test(x = observed, y = vals, alternative = "greater")$statistic
if(p == 0){p <- 0.001}
jpeg(paste("./results/Performance/plots/", i, "_", name, ".jpg", sep = ""), width = 3000, height = 3000, res = 600)
hist(vals, xlim = c(0, 1), ylim = c(0, 1000), col= "grey50", main = name, xlab = "Habitat suitability", ylab = "Frequency")
box()
abline(v = observed_median, col = "red", lty = 2, lwd = 2)
points(x = observed_median, y = 0, pch = 23, col = "black", bg = "red", cex = 1.3)
abline(v = random_median, col = "blue", lty = 2, lwd = 2)
points(x = random_median, y = 0, pch = 23, col = "black", bg = "blue", cex = 1.3)
#text(x = 0.85, y = 950, paste('P-val', " = ", paste(p)))
#text(x = 0.85, y = 900, paste('n', " = ", nrow(xy)))
legend("topright",
legend = c(paste('W', " = ", paste(W)), paste('P', " = ", paste(p)), paste('n', " = ", nrow(xy))),
bty = "n")
dev.off()
vec <- append(vec, p)
names(vec)[i] <- name
}
results <- file("./results/Performance/performance.txt")
writeLines(paste(names(vec), vec), results)
close(results)
beepr::beep(2)
